Q: åœ¨ Example 2 çš„ assign å‡½æ•°ä¸­ ....

### example 1 

![](http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2023-08-25-160959.png)

#### struct components

##### ACell
- ACell æ˜¯ä¸€ä¸ª *tuple struct* , 
```rust
use std::marker::PhantomData;

use halo2_proofs::{arithmetic::FieldExt, circuit::*, plonk::*, poly::Rotation};

#[derive(Debug, Clone)]
struct ACell<F: FieldExt>(AssignedCell<F, F>);
```

**Why ACell ?**
1. **å°è£…å’ŒæŠ½è±¡**ï¼šé€šè¿‡ä½¿ç”¨ `ACell`ï¼Œæˆ‘ä»¬ä¸ºç”¨æˆ·æä¾›äº†ä¸€ä¸ªç®€åŒ–å’Œæ›´ç›´è§‚çš„æ¥å£ï¼Œä½¿ä»–ä»¬å¯ä»¥æ›´å®¹æ˜“åœ°ä¸å·²åˆ†é…çš„å•å…ƒæ ¼è¿›è¡Œäº¤äº’ï¼Œè€Œä¸å¿…æ¯æ¬¡éƒ½ç›´æ¥å¤„ç† `AssignedCell`ã€‚
2. **çµæ´»æ€§**ï¼šå°†æ¥ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åœ¨ `ACell` ä¸­æ·»åŠ æ›´å¤šçš„åŠŸèƒ½æˆ–å±æ€§ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšè€Œä¸å½±å“ç°æœ‰çš„ä»£ç ã€‚
3. æ•… : `ACell` ä¸»è¦æ˜¯ä¸€ä¸ªè¾…åŠ©ç»“æ„ä½“ï¼Œç”¨äºç®€åŒ–ä¸ç”µè·¯ä¸­å•å…ƒæ ¼çš„äº¤äº’ã€‚

**å…ƒç´ è®¿é—® :** 
```rust
// å› ä¸º `ACell` æ˜¯å¯¹ `AssignedCell` çš„ç®€å•åŒ…è£…ï¼Œ
// æ‰€ä»¥å¯ä»¥ç›´æ¥ä½¿ç”¨ `.0` è¯­æ³•æ¥è®¿é—®å…¶å†…éƒ¨çš„ `AssignedCell` :  `prev_b.0`
let c_val = prev_b.0.value().copied() + prev_c.0.value();
```

`.map` è®¿é—® :
 - å…·ä½“æ¥è¯´ï¼Œ`assign_advice` è¿”å›çš„æ˜¯ `Result<AssignedCell<F, F>, Error>`ï¼Œ `.map(ACell)` ä¼šå°†å…¶è½¬æ¢ä¸º `Result<ACell<F>, Error>` 
 - å…ƒç»„ç»“æ„ä½“æœ¬èº«å¯ä»¥ä½œä¸ºå‡½æ•°æ¥è°ƒç”¨, ç›¸å½“äºè°ƒç”¨ä¸€ä¸ªå¸¦æœ‰ä¸€ä¸ªå‚æ•°çš„æ„é€ å‡½æ•°ã€‚

```rust
// when call .map() , æˆ‘ä»¬æä¾›ä¸€ä¸ªå‡½æ•°ï¼Œå°†å…¶åº”ç”¨äº Result å†…çš„ Ok çš„å€¼ï¼ˆif soï¼‰
// æœ¬ä¾‹ä¸­ä¼ é€’çš„å‡½æ•°æ˜¯ ACell çš„æ„é€ å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬æ˜¯å°† AssignedCell è½¬æ¢æˆ ACell
// å¯¹äº tuple struct, å¦‚ `let black = Color(0, 0, 0);`
// therefore  `AssignedCell<F, F>` æœ¬èº«æ˜¯ä¸€ä¸ªå‡½æ•°
let a_cell = region
    .assign_advice(|| "a", self.config.advice[0], 0, || a)
    .map(ACell)?;
```

##### FiboConfig / FiboChip

```rust
struct FiboConfig {
    pub advice: [Column<Advice>; 3],
    pub selector: Selector,
    pub instance: Column<Instance>,
}

struct FiboChip<F: FieldExt> {
    config: FiboConfig, // â†‘ ğŸ‘†ğŸ»
    _marker: PhantomData<F>,
}
```

#### impl FiboChip { ...
##### fn configure

 - `meta`: æ˜¯å¯¹çº¦æŸç³»ç»Ÿçš„å¯å˜å¼•ç”¨ï¼Œå…è®¸æˆ‘ä»¬åœ¨å…¶ä¸­é…ç½®åˆ—å’Œçº¦æŸã€‚
 - Selector : ç”¨äºæ¿€æ´»æˆ–ç¦ç”¨æŸäº›ç‰¹å®šçº¦æŸ
 - `meta.query_selector` : Query a selector at the current position.
 - `Query an advice column at a relative position` : Query an advice column at a relative position

```rust
impl<F: FieldExt> FiboChip<F> {
    pub fn construct(config: FiboConfig) -> Self {
        Self {
            config,
            _marker: PhantomData,
        }
    }

    pub fn configure(
        meta: &mut ConstraintSystem<F>,
        advice: [Column<Advice>; 3],
        instance: Column<Instance>,
    ) -> FiboConfig {
        let col_a = advice[0]; // å¯¹æ¯ä¸ª advice åˆ—è¿›è¡Œå‘½å
        let col_b = advice[1];
        let col_c = advice[2];
        let selector = meta.selector();

        meta.enable_equality(col_a);
        meta.enable_equality(col_b);
        meta.enable_equality(col_c);
        meta.enable_equality(instance);

        meta.create_gate("add", |meta| {
            //
            // col_a | col_b | col_c | selector
            //   a      b        c       s
            //
            // Query a selector at the current position.
            let s = meta.query_selector(selector);
            let a = meta.query_advice(col_a, Rotation::cur());
            let b = meta.query_advice(col_b, Rotation::cur());
            let c = meta.query_advice(col_c, Rotation::cur());
            vec![s * (a + b - c)]
        });

        FiboConfig {
            advice: [col_a, col_b, col_c],
            selector,
            instance,
        }
    }
```

##### fn assign_first_row

- æœ¬å‡½æ•°çš„ä½œç”¨: ä¸º Fibonacci list çš„ç¬¬ä¸€è¡Œçš„å‰ 2 ä¸ªå…ƒç´ åˆ†é…å€¼ `1 `  , è¿”å›å‰ 3 ä¸ªå…ƒç´  `a_cell, b_cell, c_cell`
- `layouter.assign_region`
	- `region.assign_advice(|| "a", self.config.advice[0], 0, || a)`
	- å‡½æ•°æºç : [[halo2 Source Code#assign_advice]]

```rust
#[allow(clippy::type_complexity)]
pub fn assign_first_row(
	&self,
	mut layouter: impl Layouter<F>,
	a: Value<F>,
	b: Value<F>,
) -> Result<(ACell<F>, ACell<F>, ACell<F>), Error> {
	layouter.assign_region(
		|| "first row",
		|mut region| {
			self.config.selector.enable(&mut region, 0)?;

			let a_cell = region
				.assign_advice(|| "a", self.config.advice[0], 0, || a)
				.map(ACell)?;

			let b_cell = region
				.assign_advice(|| "b", self.config.advice[1], 0, || b)
				.map(ACell)?;

			let c_cell = region
				.assign_advice(|| "c", self.config.advice[2], 0, || a + b)
				.map(ACell)?;

			Ok((a_cell, b_cell, c_cell))
		},
	) }
```

##### fn assign_row

 - `layouter.assign_region`
	 - `copy_advice()`å°† `prev_b` å’Œ `prev_c` çš„å€¼å¤åˆ¶åˆ°å½“å‰è¡Œçš„ **å‰ 2 åˆ—(a/b column)**ã€‚è¿™æ„å‘³ç€å‰ä¸€ä¸ª`b`å€¼è¢«å¤åˆ¶åˆ°æ–°è¡Œçš„ç¬¬ä¸€åˆ—ï¼ˆæ ‡è®°ä¸º`a`ï¼‰ï¼Œå‰ä¸€ä¸ª`c`å€¼è¢«å¤åˆ¶åˆ°æ–°è¡Œçš„ç¬¬äºŒåˆ—ï¼ˆæ ‡è®°ä¸º`b`ï¼‰
	 - è®¡ç®—æ–°çš„æ–æ³¢é‚£å¥‘æ•°`c_val`ï¼Œå®ƒæ˜¯`prev_b`å’Œ`prev_c`çš„å’Œã€‚
	 - ä½¿ç”¨`assign_advice`åˆ†é…`c_val`åˆ°æ–°è¡Œçš„ç¬¬ä¸‰åˆ—ï¼Œå¹¶è¿”å›æ­¤å€¼çš„ `ACell`

```rust
pub fn assign_row(
  &self, // å½“å‰`FiboChip`å®ä¾‹çš„å¼•ç”¨
  mut layouter: impl Layouter<F>,
  prev_b: &ACell<F>,
  prev_c: &ACell<F>,  // Fibonacci æ•°åˆ—ä¸­çš„å‰ 2 ä¸ªæ•°å­—
) -> Result<ACell<F>, Error> {
  layouter.assign_region(
    || "next row",
    |mut region| {
      self.config.selector.enable(&mut region, 0)?;

      prev_b
        .0
        .copy_advice(|| "a", &mut region, self.config.advice[0], 0)?;
      prev_c
        .0
        .copy_advice(|| "b", &mut region, self.config.advice[1], 0)?;

      let c_val = prev_b.0.value().copied() + prev_c.0.value();

      let c_cell = region
        .assign_advice(|| "c", self.config.advice[2], 0, || c_val)
        .map(ACell)?;

      Ok(c_cell)
    },
  )
}
```

#### fn expose_public
 - `expose_public` : å°†æŒ‡å®šçš„ `ACell` å…¬å¼€ä¸º Public Input.

```rust
pub fn expose_public(
	&self,
	mut layouter: impl Layouter<F>,
	cell: &ACell<F>,
	row: usize,
) -> Result<(), Error> {
	layouter.constrain_instance(cell.0.cell(), self.config.instance, row)
}

// 
chip.expose_public(layouter.namespace(|| "private a"), &prev_a, 0)?;
chip.expose_public(layouter.namespace(|| "private b"), &prev_b, 1)?;
```

#### MyCircuit
1. `let chip = FiboChip::construct(config);` : ä¼ å…¥ `config` åˆ›å»ºä¸€ä¸ªæ–°çš„ `FiboChip` å®ä¾‹
2. `chip.assign_first_row(layouter.namespace(|| "first row"), self.a, self.b)?;` : **åˆå§‹åŒ–æ–æ³¢é‚£å¥‘æ•°åˆ—**:  è°ƒç”¨ assign_first_row å‡½æ•°ä»¥åœ¨ç¬¬ä¸€è¡Œä¸­è®¾ç½®æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰ä¸¤ä¸ªå€¼ self.a å’Œ self.bã€‚è¿”å›çš„ç»“æœæ˜¯ä¸‰ä¸ªå€¼ï¼šprev_a, prev_b å’Œ prev_cã€‚å…¶ä¸­ï¼Œprev_c æ˜¯å‰ä¸¤ä¸ªæ•°çš„å’Œ 
3. `chip.expose_public(layouter.namespace(|| "private a"), &prev_a, 0)?;` : **å…¬å¼€å‰ä¸¤ä¸ªæ•°**:  å°†å‰ä¸¤ä¸ªæ•° expose ä¸º public, è¿™æ„å‘³ç€è¿™äº›å€¼å¯ä»¥è¢« $Verifier$ è®¿é—®å’ŒéªŒè¯
4. **è®¡ç®—åç»­çš„æ–æ³¢é‚£å¥‘æ•°**: ` for` å¾ªç¯ä¸­ï¼Œ`assign_row` å‡½æ•°è¢«è°ƒç”¨ä»¥è®¡ç®—åç»­çš„æ–æ³¢é‚£å¥‘æ•°ã€‚æ¯æ¬¡è¿­ä»£éƒ½ä¼šç”Ÿæˆæ–°çš„æ–æ³¢é‚£å¥‘æ•°å¹¶ä¸ºä¸‹ä¸€æ¬¡è¿­ä»£æ›´æ–° `prev_b` å’Œ `prev_c`
5. `chip.expose_public(layouter.namespace(|| "out"), &prev_c, 2)?;` : **å…¬å¼€æœ€ç»ˆçš„æ–æ³¢é‚£å¥‘æ•°**:  å°†å¾ªç¯ç»“æŸåçš„æœ€åä¸€ä¸ªæ–æ³¢é‚£å¥‘æ•°å€¼è®¾ä¸º Public

```rust
#[derive(Default)]
struct MyCircuit<F> {
    pub a: Value<F>,
    pub b: Value<F>,
}

impl<F: FieldExt> Circuit<F> for MyCircuit<F> {
    type Config = FiboConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
        let col_a = meta.advice_column();
        let col_b = meta.advice_column();
        let col_c = meta.advice_column();
        let instance = meta.instance_column();
        FiboChip::configure(meta, [col_a, col_b, col_c], instance)
    }

    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        let chip = FiboChip::construct(config);

        let (prev_a, mut prev_b, mut prev_c) =
            chip.assign_first_row(layouter.namespace(|| "first row"), self.a, self.b)?;

        chip.expose_public(layouter.namespace(|| "private a"), &prev_a, 0)?;
        chip.expose_public(layouter.namespace(|| "private b"), &prev_b, 1)?;

        for _i in 3..10 {
            let c_cell = chip.assign_row(layouter.namespace(|| "next row"), &prev_b, &prev_c)?;
            prev_b = prev_c;
            prev_c = c_cell;
        }

        chip.expose_public(layouter.namespace(|| "out"), &prev_c, 2)?;

        Ok(())
    }
}
```

#### Test
```rust
#[cfg(test)]
mod tests {
    use super::MyCircuit;
    use halo2_proofs::{circuit::Value, dev::MockProver, pasta::Fp};

    #[test]
    fn test_example1() {
        let k = 4;

        let a = Fp::from(1); // F[0]
        let b = Fp::from(1); // F[1]
        let out = Fp::from(55); // F[9]

        let circuit = MyCircuit {
            a: Value::known(a),
            b: Value::known(b),
        };

        let mut public_input = vec![a, b, out];

        let prover = MockProver::run(k, &circuit, vec![public_input.clone()]).unwrap();
        prover.assert_satisfied();

        public_input[2] += Fp::one();
        let _prover = MockProver::run(k, &circuit, vec![public_input]).unwrap();
        // uncomment the following line and the assert will fail
        // _prover.assert_satisfied();
    }
```

```bash
cargo test fibonacci::example1  `or`
cargo test -- --nocapture fibonacci::example1
```

### Example 2

the problem we noticed like inside example-1  is that there are basically
 - **too many duplicate cells** , so every time you need copy two cells from previous row to next row , not efficient 
 - *better solution* :  Use rotation to access to the multiple rows.

<img src="http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2023-08-27-005058.png" width="50%" />


åœ¨æœ¬ä¾‹å­ä¸­, ä»£ç å°†æ›´åŠ ç´§å‡‘å’Œæ¨¡å—åŒ–, ä»¥ä¸‹æ˜¯ä¸€äº›ä¸»è¦çš„åŒºåˆ« :

1. **Advice Columns**:    
    - **ex 1** : 
	    - ç”¨äº† 3 ä¸ª advice columnsï¼š`col_a`, `col_b` å’Œ `col_c`ï¼Œè¿™ 3 ä¸ª columns çš„ç¬¬ä¸€è¡Œç”¨æ¥å­˜å‚¨ Fibonacci åºåˆ—çš„è¿ç»­çš„ 3 ä¸ªæ•°
	    - `configure()` åœ¨ 3 ä¸ª advice columns ä¸­ä¸ºæ¯ä¸€ä¸ªéœ€å¯ç”¨ `enable_equality`ï¼Œå¹¶ä¸ºæ¯ä¸€ä¸ªéƒ½å»ºç«‹äº†é—¨çº¦æŸã€‚
    - **ex 2**: 
	    - ä»…ä½¿ç”¨äº†**ä¸€ä¸ª** advice columnï¼Œå¹¶ä¾èµ– rotationï¼ˆè½®è½¬, å³ $\color{red}row$ï¼‰æ¥è®¿é—®è¿ç»­çš„æ•°, å‡å°‘äº†å„ç§å¤åˆ¶

```rust
// example-1
pub fn configure(
	.., advice: [Column<Advice>; 3], .. 
	{
    let col_i = advice[ii];	
    meta.enable_equality(col_i); // å¾ˆå¤šåˆ—éœ€è¦å£°æ˜, éœ€è¦ enable...

    meta.create_gate("add", |meta| {
        let s = meta.query_selector(selector);
        let a = meta.query_advice(col_a, Rotation::cur()); //ğŸ“¢
        let b = meta.query_advice(col_b, Rotation::cur()); //ğŸ“¢
        let c = meta.query_advice(col_c, Rotation::cur()); //ğŸ“¢

}

----------------------------------------

// example-2
pub fn configure(  
	.., advice: Column<Advice>, .. 
	{
    meta.enable_equality(advice); //æ‰€æœ‰ advice åˆ—åªåœ¨æ­¤ enable once.

    meta.create_gate("add", |meta| {
        let s = meta.query_selector(selector);
        let a = meta.query_advice(advice, Rotation::cur()); //ğŸ’¡
        let b = meta.query_advice(advice, Rotation::next());//ğŸ’¡
        let c = meta.query_advice(advice, Rotation(2));}    //ğŸ’¡
```

 - `Rotation::cur()`  å½“å‰è¡Œ 
 - `Rotation::next()`  ä¸‹ä¸€è¡Œ
 - `Rotation(2)`  å†ä¸‹ä¸€è¡Œ

The Polynomial Identity : 
$$
S(x) \cdot \left( A(\textcolor{red}{x}) + A(\textcolor{red}{\omega x})  - A(\textcolor{red}{\omega^2 x}) \right) = 0
$$


2. **æ•°æ®èµ‹å€¼**:
    - **ex 1**: åˆå§‹çš„ Fibonacci æ•° `a` å’Œ `b` è¢«èµ‹å€¼åˆ°ä¸¤ä¸ªä¸åŒçš„ advice columnsï¼Œè€Œä»–ä»¬çš„å’Œåˆ™è¢«èµ‹å€¼åˆ°ç¬¬ä¸‰ä¸ª columnã€‚
    - **ex 2**: æ‰€æœ‰çš„ Fibonacci æ•°éƒ½åœ¨åŒä¸€ä¸ª advice columnï¼Œä½†åœ¨ä¸åŒçš„è¡Œ (thanks to rotation)

```rust
////  Example 2  ////
pub fn assign(..., nrows){
  layouter.assign_region("entire fibonacci table",
    |mut region| {
    // ä¸ºå‰ä¸¤è¡Œå¯ç”¨ selector,è¿™æ„å‘³ç€æˆ‘ä»¬å°†ä» instance åˆ—ï¼ˆå¯èƒ½æ˜¯å…¬å…±è¾“å…¥ï¼‰
    // ä¸­å¤åˆ¶ Fibonacci åºåˆ—çš„å‰ 2 ä¸ªæ•°å­—
    self.config.selector.enable(&mut region, 0)?;
    self.config.selector.enable(&mut region, 1)?;

    // assign_advice_from_instance æ–¹æ³•ï¼Œå°† instance åˆ—çš„å‰ä¸¤ä¸ªå€¼
	//   (å³ Fibonacci åºåˆ—çš„å‰ä¸¤ä¸ªæ•°å­—ï¼‰èµ‹ç»™ advice åˆ—ä¸­çš„å‰ä¸¤ä¸ªå•å…ƒæ ¼
	//   åé¢åœ¨ MockProver ä¸­, æˆ‘ä»¬ä¼šä¼ å…¥ instance ä½œä¸º Public input
	let mut a_cell = region.assign_advice_from_instance(
		|| "1",
		self.config.instance,
		0,
		self.config.advice,
		0,  // row
	)?;
	let mut b_cell = region.assign_advice_from_instance(
		|| "1",
		self.config.instance,
		1,  // è¿™é‡Œå†™ 0 ä¹Ÿä¸æŠ¥é”™, å†™ 1/2/3 å°±ä¼šæŠ¥é”™äº†..
		self.config.advice,
		1,  // row
    )?;
    
	// èµ‹å€¼å¥½äº†å‰ 2 è¡Œ(é€’å½’åŸº) ,å…¶ä½™çš„è¡Œå°±ç´¯åŠ è¿‡å»å°±å¥½äº†
	for row in 2..nrows {
		if row < nrows - 2 {
			self.config.selector.enable(&mut region, row)?;
		}

		let c_cell = region.assign_advice(
			|| "advice",
			self.config.advice,
			row,
			|| a_cell.value().copied() + b_cell.value(),
		)?;

		a_cell = b_cell;
		b_cell = c_cell;
	}

	Ok(b_cell)	
}
```


3. **ç”Ÿæˆçš„ Fibonacci æ•°**:    
    - **Version 1**: ä½¿ç”¨æ–¹æ³• `assign_row` ä»å‰ä¸¤ä¸ªæ•°ç”Ÿæˆä¸‹ä¸€ä¸ªæ•°ã€‚
    - **Version 2**: ä½¿ç”¨ä¸€ä¸ªå¾ªç¯åœ¨æ•´ä¸ª Fibonacci è¡¨æ ¼ä¸­ä¸ºæ‰€æœ‰çš„æ•°èµ‹å€¼ã€‚

```rust
////  Example 2  ////
pub fn assign(..., nrows){
	// èµ‹å€¼å¥½äº†å‰ 2 è¡Œ(é€’å½’åŸº) ,å…¶ä½™çš„è¡Œå°±ç´¯åŠ è¿‡å»å°±å¥½äº†
	for row in 2..nrows {
		if row < nrows - 2 {
			self.config.selector.enable(&mut region, row)?;
		}

		let c_cell = region.assign_advice(
			|| "advice",
			self.config.advice,
			row,
			|| a_cell.value().copied() + b_cell.value(),
		)?;

		a_cell = b_cell;
		b_cell = c_cell;
	}

	Ok(b_cell)
}
```

å¦‚ä¸‹ `instance` , é‡Œé¢æ˜¯ Public input 

```rust
#[test]
fn test_example2() {
	let k = 4;

	let a = Fp::from(1); // F[0]
	let b = Fp::from(1); // F[1]
	let out = Fp::from(55); // F[9]

	let circuit = MyCircuit(PhantomData);

	let mut public_input = vec![a, b, out];

	let prover = MockProver::run(k, &circuit, vec![public_input.clone()]).unwrap();
	prover.assert_satisfied();

	public_input[2] += Fp::one();
	let _prover = MockProver::run(k, &circuit, vec![public_input]).unwrap();
	// uncomment the following line and the assert will fail
	// _prover.assert_satisfied();
}
```

#### print

 - the white column is the instance column, 
 - the pink one is the advice and 
 - the purple one is the selector.
 - the green part shows the cells that have been assigned
	 - light green : selector not used.

```bash
cargo test --all-features -- --nocapture print
```

change k from 13 to 4, the line will be more small so now you are not calim about the main function .

 - the MockProver will tell you constrains that $\textcolor{red}{failed}$ ,
 - the `png` will tell you a Â $\textcolor{blue}{missing}$Â  constraint `you have ignored` !


#### Row & Column in Region 

Compared  `example-1 ` with `example-2`  : 

```rust
meta.create_gate("add", |meta| {
	// col_a | col_b | col_c | selector
	//   a      b        c       s
	let s = meta.query_selector(selector);
	let a = meta.query_advice(col_a, Rotation::cur());
	let b = meta.query_advice(col_b, Rotation::cur());
	let c = meta.query_advice(col_c, Rotation::cur());
	vec![s * (a + b - c)]

---------------------------------------------

meta.create_gate("add", |meta| {
	// advice | selector
	//   a    |   s
	//   b    |
	//   c    |
	let s = meta.query_selector(selector);
	let a = meta.query_advice(advice, Rotation::cur());
	let b = meta.query_advice(advice, Rotation::next());
	let c = meta.query_advice(advice, Rotation(2));
	vec![s * (a + b - c)] 
```

We see : 
 - `col_a / col_b / col_c` represent different  $\color{red}columns$
 - `Rotation::cur() / Rotation::next() / Rotation::prev() / Rotation(2)`  represent different $\color{red}rows$

```bash
cargo test -- --nocapture fibonacci::example2
```

### Reference :
 - [Jason Morton](https://github.com/jasonmorton/halo2-examples/blob/master/src/fibonacci/example1.rs)

