msgid ""
msgstr ""
"Project-Id-Version: SONiC入门指南\n"
"POT-Creation-Date: 2023-10-23T23:38:37+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:5
msgid "1"
msgstr ""

#: src/plonk-arithmetization.md:1
msgid "理解 PLONK（一）：Plonkish Arithmetization"
msgstr "Understanding PLONK (Part 1): Plonkish Arithmetization"

#: src/plonk-arithmetization.md:4
msgid ""
"算术化是指把计算转换成数学对象，然后进行零知识证明。 Plonkish 算术化是 Plonk "
"证明系统特有的算术化方法，在 Plonkish 出现之前，主流的电路表达形式为 R1CS，"
"被 Pinocchio，Groth16，Bulletproofs 等广泛采用。2019 年 Plonk 方案提出了一种"
"看似复古的电路编码方式，但由于 Plonk 方案将多项式的编码应用到了极致，它不再局"
"限于算术电路中的「加法门」和「乘法门」，而是可以支持更灵活的「自定义门」与"
"「查表门」。"
msgstr ""
"Arithmetization refers to transforming computations into mathematical "
"objects and then performing zero-knowledge proofs. Plonkish arithmetization "
"is a specific arithmetization method in the Plonk proof system. Prior to the "
"introduction of Plonkish, the mainstream circuit representation was R1CS, "
"widely used in systems such as Pinocchio, Groth16, and Bulletproofs. In "
"2019, the Plonk scheme proposed a seemingly retrograde circuit encoding "
"method. However, due to its extreme application of polynomial encoding, "
"Plonk is no longer limited to \"addition gates\" and \"multiplication "
"gates\" in arithmetic circuits, but can support more flexible \"custom "
"gates\" and \"lookup gates\"."

#: src/plonk-arithmetization.md:6
msgid ""
"我们先回顾一下 R1CS 的电路编码，也是相关介绍最多的算术化方案。然后我们对比引"
"入 Plonkish 编码。"
msgstr ""
"Let's first review the circuit encoding of R1CS, which is the most commonly "
"used arithmetic scheme. Then we will compare it with the introduction of "
"Plonkish encoding."

#: src/plonk-arithmetization.md:8
msgid "算术电路与 R1CS 算术化"
msgstr "Arithmetic circuits and arithmeticization of R1CS"

#: src/plonk-arithmetization.md:10
msgid ""
"一个算术电路包含若干个乘法门与加法门。每一个门都有「两个输入」引脚和一个「输"
"出」引脚，任何一个输出引脚可以被接驳到多个门的输入引脚上。"
msgstr ""
"An arithmetic circuit consists of several multiplication gates and addition "
"gates. Each gate has \"two input\" pins and one \"output\" pin, and any "
"output pin can be connected to multiple input pins of gates."

#: src/plonk-arithmetization.md:12
msgid "先看一个非常简单的算术电路："
msgstr "First, let's look at a very simple arithmetic circuit:"

#: src/plonk-arithmetization.md:14
msgid "![img20230414162317](img/img20230414162317.png)"
msgstr ""

#: src/plonk-arithmetization.md:16 src/plonk-arithmetization.md:117
msgid "这个电路表示了这样的一个计算："
msgstr "This circuit represents such a calculation:"

#: src/plonk-arithmetization.md:18
msgid "$$ (x_1 + x_2) \\cdot (2\\cdot x_3) = out $$"
msgstr ""

#: src/plonk-arithmetization.md:22
msgid ""
"电路中有4个变量，其中三个变量为输入变量 $(x_1, x_2, x_3)$ ，一个输出变量 "
"$out$，其中还有一个输入为常数，其值为 $2$。"
msgstr ""
"There are 4 variables in the circuit, with three variables being input "
"variables $(x_1, x_2, x_3)$, one output variable $out$, and one constant "
"input with a value of $2$."

#: src/plonk-arithmetization.md:24
msgid ""
"一个电路有两种状态：「空白态」和「运算态」。当输入变量没有具体值的时候，电路"
"处于「空白态」，这时我们只能描述电路引线之间的关系，即电路的结构拓扑。"
msgstr ""
"A circuit has two states: \"blank state\" and \"operational state\". When "
"the input variables do not have specific values, the circuit is in the "
"\"blank state\", and we can only describe the relationship between the "
"circuit wires, or the structural topology of the circuit."

#: src/plonk-arithmetization.md:27
msgid "![](img/img20230414162845.png)"
msgstr ""

#: src/plonk-arithmetization.md:29
msgid ""
"接下来的问题是，我们要先编码电路的「空白态」，即编码各个门的位置，和他们之间"
"引线连接关系。"
msgstr ""
"The next step is to encode the \"blank state\" of the circuit, which means "
"encoding the positions of each gate and their interconnecting wire "
"relationships."

#: src/plonk-arithmetization.md:31
msgid ""
"R1CS 是通过图中的乘法门为中心，用三个「选择子」矩阵来「选择」乘法门的「左输"
"入」、「右输入」、「输出」都分别连接了那些变量。"
msgstr ""
"R1CS is centered around multiplication gates in the graph, using three "
"\"selector\" matrices to connect the \"left input,\" \"right input,\" and "
"\"output\" of the multiplication gates to respective variables."

#: src/plonk-arithmetization.md:33
msgid "我们先看看图中最上面的乘法门的左输入，可以用下面的表格来描述："
msgstr ""
"Let's start by looking at the left input of the multiplication gate at the "
"top of the diagram. It can be described using the table below:"

#: src/plonk-arithmetization.md:35
msgid ""
"$$ \\\\begin{array}{|c|c|c|c|c|} \\\\hline 1 & x_1 & x_2 & x_3 & out \\\\ \\"
"\\hline 0 & 1 & 1 & 0 & 0 \\\\ \\\\hline \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:45
msgid ""
"这个表格只有一行，因此我们可以用一个向量 $U=(0,1,1,0,0)$ 来代替，表示乘法门的"
"左输入连接了两个变量， $x_1$ 和 $x_2$。记住，所有的加法门都会被展开成多个变量"
"的相加（或线性组合）。"
msgstr ""
"This form has only one row, so we can use a vector $U=(0,1,1,0,0)$ to "
"represent that the left input of the multiplication gate is connected to two "
"variables, $x_1$ and $x_2$. Remember, all addition gates will be expanded "
"into sums (or linear combinations) of multiple variables."

#: src/plonk-arithmetization.md:47
msgid ""
"再看看其右输入，连接了一个变量 $x_3$ 和一个常数值，等价于连接了 $x_3$ 的两"
"倍，那么右输入的选择子矩阵可以记为 "
msgstr ""
"Take another look at the right input, which is connected to a variable $x_3$ "
"and a constant value, equivalent to connecting twice the value of $x_3$. "
"Therefore, the selector matrix of the right input can be denoted as."

#: src/plonk-arithmetization.md:49
msgid ""
"$$ \\\\begin{array}{|c|c|c|c|c|} \\\\hline 1 & x_1 & x_2 & x_3 & out \\\\ \\"
"\\hline 0 & 0 & 0 & 2 & 0 \\\\ \\\\hline \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:59
msgid ""
"这里同样可以用一个行向量 $V=(0,0,0,2,0)$ 来表示，其中的 $2$ 即为上图中电路的"
"常数引线。"
msgstr ""
"Here, it can also be represented by a row vector $V=(0,0,0,2,0)$, where the "
"$2$ represents the constant terminal of the circuit in the above diagram."

#: src/plonk-arithmetization.md:61
msgid ""
"最后乘法门的输出按照上面的方法可以描述为 $W=(0,0,0,0,1)$，即输出变量为 "
"$out$："
msgstr ""
"The output of the final multiplication gate can be described as "
"$W=(0,0,0,0,1)$, with the output variable being $out$."

#: src/plonk-arithmetization.md:63
msgid ""
"$$ \\\\begin{array}{|c|c|c|c|c|} \\\\hline 1 & x_1 & x_2 & x_3 & out \\\\ \\"
"\\hline 0 & 0 & 0 & 0 & 1 \\\\ \\\\hline \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:73
msgid "有了三个向量 $(U,V,W)$，我们可以通过一个「内积」等式来约束电路的运算："
msgstr ""
"With three vectors (U, V, W), we can constrain the operation of the circuit "
"through an \"inner product\" equation:"

#: src/plonk-arithmetization.md:75
msgid ""
"$$ \\\\big(U\\cdot(1,x_1, x_2,x_3,out)\\big) \\cdot \\big(V\\cdot(1,x_1, x_2,"
"x_3,out)\\big) = \\big(W\\cdot(1,x_1, x_2,x_3,out)\\big) $$"
msgstr ""

#: src/plonk-arithmetization.md:79
msgid "这个等式化简之后正好可以得到："
msgstr "After simplifying this equation, we can obtain:"

#: src/plonk-arithmetization.md:81
msgid "$$ (x_1 + x2) \\cdot (2\\cdot x_3) = out $$"
msgstr ""

#: src/plonk-arithmetization.md:85
msgid ""
"如果我们把这几个变量换成赋值向量 $(1,x_1,x_2,x_3,out) = (1,3,4,5,70)$，那么电"
"路的运算可以通过「内积」等式来验证："
msgstr ""
"If we substitute these variables with the assignment vector $(1,x_1,x_2,x_3,"
"out) = (1,3,4,5,70)$, then the circuit operation can be verified through the "
"\"inner product\" equation:"

#: src/plonk-arithmetization.md:87
msgid ""
"$$ (U\\cdot(1,3,4,5,70))\\cdot(U\\cdot(1,3,4,5,70))=W\\cdot(1,3,4,5,70) $$"
msgstr ""

#: src/plonk-arithmetization.md:91
msgid ""
"而一个错误的赋值向量，比如 $(1,3,4,\\fbox{0},70)$ ，则不满足「内积等式」："
msgstr ""
"And if we have an incorrectly assigned vector, such as $(1,3,4,"
"\\fbox{0},70)$, it does not satisfy the \"inner product equation\":"

#: src/plonk-arithmetization.md:93
msgid ""
"$$ (U\\cdot(1,3,4,\\fbox{0},70))\\cdot(U\\cdot(1,3,4,\\fbox{0},70))\\neq "
"W\\cdot(1,3,4,\\fbox{0},70) $$"
msgstr ""

#: src/plonk-arithmetization.md:97
msgid ""
"左边运算结果为 $0$，右边运算结果为 $70$。当然，我们可以验证 $(1,3,4,0,0)$ 也"
"是一组合法（满足电路约束）的赋值。"
msgstr ""
"The result of the left-side arithmetic is $0$, and the result of the right-"
"side arithmetic is $70$. Of course, we can verify that $(1,3,4,0,0)$ is also "
"a valid (satisfying circuit constraints) assignment."

#: src/plonk-arithmetization.md:99
msgid ""
"并不是任何一个电路都存在赋值向量。凡是存在合法的赋值向量的电路，被称为可被满"
"足的电路。判断一个电路是否可被满足，是一个 NP-Complete 问题，也是一个 NP 困难"
"问题。"
msgstr ""
"Not every circuit has an assignment vector. Circuits that have a valid "
"assignment vector are called satisfiable circuits. Determining whether a "
"circuit is satisfiable is an NP-Complete problem and also an NP-hard problem."

#: src/plonk-arithmetization.md:101
msgid ""
"这里例子中的两个乘法门并不相同，上面的乘法门是左右输入中都含有变量，而下面的"
"乘法门只有一边的输入为变量，另一边为常数。对于后者这类「常数乘法门」，后续我"
"们也把他们看作为特殊的「加法门」，如下图所示，左边电路右下的乘法门等价于右边"
"电路的右下加法门。"
msgstr ""
"The two multiplication gates in the examples are not the same. The "
"multiplication gate above has variables in both inputs, while the "
"multiplication gate below has a variable on one side and a constant on the "
"other side. For the latter type of \"constant multiplication gate\", we also "
"consider them as special \"addition gates\". As shown in the diagram below, "
"the multiplication gate in the bottom right of the left circuit is "
"equivalent to the addition gate in the bottom right of the right circuit."

#: src/plonk-arithmetization.md:105
msgid "![](img/img20230423133455.png)"
msgstr ""

#: src/plonk-arithmetization.md:109
msgid ""
"那么如果一个电路含有两个以上的乘法门，我们就不能用 $U,V,W$ 三个向量之间的内积"
"关系来表示运算，而需要构造「三个矩阵」的运算关系。"
msgstr ""
"So if a circuit contains more than two multiplication gates, we cannot use "
"the inner product relationship between the vectors $U, V, W$ to represent "
"the operation, and we need to construct an operation relationship between "
"\"three matrices\"."

#: src/plonk-arithmetization.md:111
msgid "多个乘法门"
msgstr "Multiple multiplication gates"

#: src/plonk-arithmetization.md:113
msgid "比如下图所示电路，有两个乘法门，他们的左右输入都涉及到变量。"
msgstr ""
"For example, in the circuit shown below, there are two multiplication gates, "
"and both their left and right inputs involve variables."

#: src/plonk-arithmetization.md:115
msgid "![c](img/img20230414170601.png)"
msgstr ""

#: src/plonk-arithmetization.md:119
msgid "$$ (x_1 + x2) \\cdot (x3 \\cdot x4) = out $$"
msgstr ""

#: src/plonk-arithmetization.md:123
msgid ""
"我们以**乘法门**为基准，对电路进行编码。第一步将电路中的乘法门依次编号（无所"
"谓编码顺序，只要前后保持一致）。图中的两个乘法门编码为 `#1` 与 `#2`。"
msgstr ""
"We encode the circuit based on the **multiplication gates**. In the first "
"step, the multiplication gates in the circuit are numbered sequentially (the "
"order of numbering doesn't matter as long as it is consistent). The two "
"multiplication gates in the diagram are encoded as `#1` and `#2`."

#: src/plonk-arithmetization.md:125
msgid ""
"然后我们需要为每一个乘法门的中间值引线也给出变量名：比如四个输入变量被记为 "
"$x_1, x_2, x_3, x_4$，其中 $x_5$ 为第二个乘法门的输出，同时作为第一个乘法门的"
"右输入。而 $out$ 为第一个乘法门的输出。于是我们可以得到一个关于变量名的向量："
msgstr ""
"And then we need to give variable names to the intermediate wires of each "
"multiplication gate: for example, four input variables are denoted as $x_1, "
"x_2, x_3, x_4$, with $x_5$ being the output of the second multiplication "
"gate and also serving as the right input of the first multiplication gate. "
"And $out$ is the output of the first multiplication gate. Therefore, we can "
"obtain a vector of variable names:"

#: src/plonk-arithmetization.md:127
msgid "$$ (x_1, x_2, x_3, x_4, x_5, out) $$"
msgstr ""

#: src/plonk-arithmetization.md:131
msgid "该电路的「空白态」可以用下面的三个矩阵来编码："
msgstr ""
"The \"blank state\" of this circuit can be encoded using the following three "
"matrices:"

#: src/plonk-arithmetization.md:133
msgid "$$ U, V, W \\in \\mathbb{F}^{n\\times m} $$"
msgstr ""

#: src/plonk-arithmetization.md:137
msgid ""
"其中 $n$ 为乘法门的数量，而 $m$ 大致为引线的数量。每一个矩阵的第 $i$ 行「选"
"择」了第 $i$ 个乘法门的输入输出变量。比如我们定义电路的左输入矩阵  $U$ ："
msgstr ""
"I understand. Here is the text:\n"
"\n"
"Where $n$ is the number of multiplication gates, and $m$ is approximately "
"the number of wires. Each row of the matrix \"selects\" the input/output "
"variables of the corresponding multiplication gate. For example, we define "
"the left input matrix $U$ of the circuit:"

#: src/plonk-arithmetization.md:139
msgid ""
"$$ \\\\begin{array}{|c|c|c|c|c|} \\\\hline x_1 & x_2 & x_3 & x_4 & x_5 & out "
"& \\texttt{i} \\\\ \\\\hline 1 & 1 & 0 & 0 & 0 & 0 & \\texttt{1}\\\\ \\"
"\\hline 0 & 0 & 1 & 0 & 0 & 0 & \\texttt{2}\\\\ \\\\hline \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:151
msgid ""
"其中第一个乘法门的左输入为 $(x_1+x_2)$， 第二个乘法门的左输入为 $x_3$。右输入"
"矩阵 $V$ 定义为："
msgstr ""
"The left input of the first multiplier gate is $(x_1 + x_2)$, and the left "
"input of the second multiplier gate is $x_3$. The right input matrix $V$ is "
"defined as:"

#: src/plonk-arithmetization.md:153
msgid ""
"$$ \\\\begin{array}{|c|c|c|c|c|} \\\\hline x_1 & x_2 & x_3 & x_4 & x_5 & out "
"&\\texttt{i}\\\\ \\\\hline 0 & 0 & 0 & 0 & 1 & 0 & \\texttt{1}\\\\ \\\\hline "
"0 & 0 & 0 & 1 & 0 & 0 & \\texttt{2}\\\\ \\\\hline \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:165
msgid ""
"其中1号门的右输入为 $x_5$，第二个乘法门的右输入为 $x_4$。最后定义输出矩阵 "
"$W$："
msgstr ""
"The right input of gate No. 1 is $x_5$, and the right input of the second "
"multiplication gate is $x_4$. Finally, the output matrix $W$ is defined as "
"follows:"

#: src/plonk-arithmetization.md:167
msgid ""
"$$ \\\\begin{array}{|c|c|c|c|c|} \\\\hline x_1 & x_2 & x_3 & x_4 & x_5 & out "
"& \\texttt{i}\\\\ \\\\hline 0 & 0 & 0 & 0 & 0 & 1 & \\texttt{1}\\\\ \\"
"\\hline 0 & 0 & 0 & 0 & 1 & 0 & \\texttt{2}\\\\ \\\\hline \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:179
msgid ""
"我们把所有的引线赋值看作为一个向量： $\\vec{a}$ （这里用字母 $a$，取自 "
"Assignments 首字母）"
msgstr ""
"We treat all the wire assignments as a vector: $\\vec{a}$ (here using the "
"letter $a$, taken from the first letter of Assignments)"

#: src/plonk-arithmetization.md:181
msgid "在上面的例子中，「赋值向量」为"
msgstr "In the above example, the \"assignment vector\" is"

#: src/plonk-arithmetization.md:183
msgid "$$ \\\\vec{a} = (x_1, x_2, x_3,x_4,x_5,out) $$"
msgstr ""

#: src/plonk-arithmetization.md:187
msgid "于是我们可以轻易地检验下面的等式"
msgstr "So we can easily verify the following equation."

#: src/plonk-arithmetization.md:189
msgid ""
"$$ (U \\cdot \\vec{a}) \\circ (V \\cdot \\vec{a}) = (W \\cdot\\vec{a}) $$"
msgstr ""

#: src/plonk-arithmetization.md:193
msgid ""
"其中符号 $\\circ$ 为 Hadamard Product，表示「按位乘法」。展开上面的按位乘法等"
"式，我们可以得到这个电路的运算过程："
msgstr ""
"The symbol $\\circ$ represents Hadamard Product, which indicates \"element-"
"wise multiplication\". Expanding the above element-wise multiplication "
"equation, we can obtain the operation process of this circuit:"

#: src/plonk-arithmetization.md:195
msgid ""
"$$ \\\\left\\[ \\\\begin{array}{c} x_1 + x_2 \\\\ x_3 \\\\ \\\\end{array} \\"
"\\right\\] \\\\circ \\\\left\\[ \\\\begin{array}{c} x_5 \\\\ x_4 \\\\ \\"
"\\end{array} \\\\right\\]= \\\\left\\[ \\\\begin{array}{c} out \\\\ x_5 \\\\ "
"\\\\end{array} \\\\right\\] $$"
msgstr ""

#: src/plonk-arithmetization.md:217
msgid ""
"请注意，通常「赋值向量」中需要一个固定赋值为 $1$ 的变量，这是为了处理加法门中"
"的常量输入。"
msgstr ""
"Please note that in general, a \"assignment vector\" needs a variable with a "
"fixed value of $1$, which is necessary to handle constant inputs in addition "
"gates."

#: src/plonk-arithmetization.md:219
msgid "优缺点"
msgstr "Advantages and disadvantages"

#: src/plonk-arithmetization.md:221
msgid ""
"由于 R1CS 编码以乘法门为中心，于是电路中的加法门并不会增加 $U, V, W$ 矩阵的行"
"数，因而对 Prover 的性能影响不大。R1CS 电路的编码清晰简单，利于在其上构造各"
"种 SNARK 方案。"
msgstr ""
"Due to the R1CS encoding being centered around multiplication gates, the "
"addition gates in the circuit do not increase the number of rows in the "
"matrices $U, V, W$, thus having little impact on the performance of the "
"Prover. The encoding of R1CS circuits is clear and simple, which facilitates "
"the construction of various SNARK schemes on top of it."

#: src/plonk-arithmetization.md:223
msgid ""
"在 2019 年 Plonk 论文中的编码方案同时需要编码加法门与乘法门，看起来因此会增加"
"约束的数量，降低 Proving 性能。但 Plonk 团队随后陆续引入了除乘法与加法外的运"
"算门，比如实现范围检查的门，实现异或运算的门等等。不仅如此，Plonk 支持任何其"
"输入输出满足多项式关系的门，即 Custom Gate，还有适用于实现 RAM 的状态转换门"
"等，随着查表门的提出，Plonk 方案逐步成为许多应用的首选方案，其编码方式也有了"
"一个专门的名词：Plonkish。"
msgstr ""
"The encoding scheme in the 2019 Plonk paper requires encoding both addition "
"and multiplication gates, which seems to increase the number of constraints "
"and decrease the proving performance. However, the Plonk team subsequently "
"introduced additional gates besides multiplication and addition, such as "
"gates for range checks and XOR operations. Moreover, Plonk supports any gate "
"with polynomial relations between its inputs and outputs, known as Custom "
"Gates, as well as state transition gates for implementing RAM. With the "
"introduction of lookup gates, the Plonk scheme gradually became the "
"preferred choice for many applications, and its encoding method also gained "
"a dedicated term: Plonkish."

#: src/plonk-arithmetization.md:225
msgid "Plonkish 算术门"
msgstr "Plonkish Arithmetic Door"

#: src/plonk-arithmetization.md:227
msgid ""
"回看下例子电路，我们把三个门全都编号， $\\texttt{1},\\texttt{2},"
"\\texttt{3}$，同时把加法门的输出值也标记为变量 $x_6$。"
msgstr ""
"Looking back at the example circuit, we will number all three gates as $"
"\\texttt{1},\\texttt{2},\\texttt{3}$, and we will also mark the output value "
"of the adder gate as variable $x_6$."

#: src/plonk-arithmetization.md:229
msgid "![](img/img20230414202348.png)"
msgstr ""

#: src/plonk-arithmetization.md:231
msgid "显然，上面的电路满足三个约束："
msgstr "Clearly, the above circuit satisfies three constraints:"

#: src/plonk-arithmetization.md:233
msgid "$x_1 + x_2 =x_6$"
msgstr "$x_1 + x_2 = x_6$"

#: src/plonk-arithmetization.md:234
msgid "$x_3\\cdot x_4 = x_5$"
msgstr "$x_3 \\cdot x_4 = x_5$"

#: src/plonk-arithmetization.md:235
msgid "$x_6 \\cdot x_5 = out$"
msgstr ""
"I understand. Here is the translation:\n"
"\n"
"\"$x_6 \\cdot x_5 = out$\"\n"
"\n"

#: src/plonk-arithmetization.md:237
msgid ""
"我们定义一个矩阵 $W\\in\\mathbb{F}^{n\\times 3}$ 来表示约束（ $n$ 为算术门的"
"数量）："
msgstr ""
"We define a matrix $W\\in\\mathbb{F}^{n\\times 3}$ to represent the "
"constraints (where $n$ is the number of arithmetic gates):"

#: src/plonk-arithmetization.md:239
msgid ""
"$$ \\\\begin{array}{c|c|c|c|} \\\\texttt{i} & w_a & w_b & w_c  \\\\ \\"
"\\hline \\\\texttt{1} & x_6 & x_5 & out \\\\ \\\\texttt{2} & x_1 & x_2 & x_6 "
"\\\\ \\\\texttt{3} & x_3 & x_4 & x_5 \\\\ \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:249
msgid ""
"为了区分加法和乘法，我们再定一个向量 $Q\\in\\mathbb{F}^{n\\times5}$ 来表示运"
"算符"
msgstr ""
"In order to differentiate addition and multiplication, we define a vector $Q "
"\\in \\mathbb{F}^{n\\times5}$ to represent the operator."

#: src/plonk-arithmetization.md:251
msgid ""
"$$ \\\\begin{array}{c|c|c|c|} \\\\texttt{i}  & q_L & q_R & q_M & q_C & q_O  "
"\\\\ \\\\hline \\\\texttt{1} & 0 & 0 & 1 & 0& 1 \\\\ \\\\texttt{2} & 1 & 1 & "
"0 & 0& 1 \\\\ \\\\texttt{3} & 0 & 0 & 1 & 0& 1 \\\\ \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:261
msgid "于是我们可以通过下面的等式来表示三个约束："
msgstr ""
"So we can represent the three constraints using the following equations:"

#: src/plonk-arithmetization.md:263 src/plonk-arithmetization.md:487
msgid ""
"$$ q_L \\circ w_a + q_R \\circ w_b + q_M\\circ(w_a\\cdot w_b) + q_C -  "
"q_O\\circ w_c = 0 $$"
msgstr ""

#: src/plonk-arithmetization.md:267
msgid "如果把上面的等式代入并展开，我们可以得到下面的约束等式："
msgstr ""
"If we substitute and expand the equation above, we can obtain the following "
"constraint equations:"

#: src/plonk-arithmetization.md:269
msgid ""
"$$ \\\\left\\[ \\\\begin{array}{c} 0\\\\ 1 \\\\ 0\\\\ \\\\end{array} \\"
"\\right\\] \\\\circ \\\\left\\[ \\\\begin{array}{c} x_6 \\\\ x_1 \\\\ x_5\\"
"\\ \\\\end{array} \\\\right\\]"
msgstr ""

#: src/plonk-arithmetization.md:286
msgid ""
"\\\\left\\[ \\\\begin{array}{c} 0\\\\ 1 \\\\ 0\\\\ \\\\end{array} \\"
"\\right\\] \\\\circ \\\\left\\[ \\\\begin{array}{c} x_5 \\\\ x_2 \\\\ x_4\\"
"\\ \\\\end{array} \\\\right\\]"
msgstr ""
"\\[\\begin{pmatrix} 0\\\\ 1 \\\\ 0\\\\ \\end{pmatrix} \\circ "
"\\begin{pmatrix} x_5 \\\\ x_2 \\\\ x_4\\\\ \\end{pmatrix}\\]"

#: src/plonk-arithmetization.md:302
msgid ""
"\\\\left\\[ \\\\begin{array}{c} 1\\\\ 0 \\\\ 1\\\\ \\\\end{array} \\"
"\\right\\] \\\\circ \\\\left\\[ \\\\begin{array}{c} x_6\\cdot x_5 \\\\ "
"x_1\\cdot x_2 \\\\ x_3\\cdot x_4\\\\ \\\\end{array} \\\\right\\]=\\left\\[ \\"
"\\begin{array}{c} 1\\\\ 1 \\\\ 1\\\\ \\\\end{array} \\\\right\\] \\\\circ \\"
"\\left\\[ \\\\begin{array}{c} out \\\\ x_6 \\\\ x_5\\\\ \\\\end{array} \\"
"\\right\\] $$"
msgstr ""
"\\[\n"
"\\left[ \\begin{array}{c} 1\\\\ 0 \\\\ 1\\\\ \\end{array} \\right] \\circ "
"\\left[ \\begin{array}{c} x_6\\cdot x_5 \\\\ x_1\\cdot x_2 \\\\ x_3\\cdot "
"x_4\\\\ \\end{array} \\right]=\\left[ \\begin{array}{c} 1\\\\ 1 \\\\ 1\\\\ "
"\\end{array} \\right] \\circ \\left[ \\begin{array}{c} out \\\\ x_6 \\\\ "
"x_5\\\\ \\end{array} \\right]\n"
"\\]"

#: src/plonk-arithmetization.md:333
msgid "化简后得："
msgstr "Simplified to:"

#: src/plonk-arithmetization.md:335
msgid ""
"$$ \\\\left\\[ \\\\begin{array}{c} 0 \\\\ x_1 \\\\ 0\\\\ \\\\end{array} \\"
"\\right\\]"
msgstr ""

#: src/plonk-arithmetization.md:344
msgid ""
"\\\\left\\[ \\\\begin{array}{c} 0 \\\\ x_2 \\\\ 0\\\\ \\\\end{array} \\"
"\\right\\]"
msgstr "\\[ \\begin{bmatrix} 0 \\\\ x_2 \\\\ 0 \\end{bmatrix} \\]"

#: src/plonk-arithmetization.md:352
msgid ""
"\\\\left\\[ \\\\begin{array}{c} x_6\\cdot x_5 \\\\ 0 \\\\ x_3\\cdot x_4\\\\ "
"\\\\end{array} \\\\right\\]=\\left\\[ \\\\begin{array}{c} out \\\\ x_6 \\\\ "
"x_5\\\\ \\\\end{array} \\\\right\\] $$"
msgstr ""
"$$\\begin{pmatrix} x_6 \\cdot x_5 \\\\ 0 \\\\ x_3 \\cdot x_4 \\end{pmatrix} "
"= \\begin{pmatrix} \\text{out} \\\\ x_6 \\\\ x_5 \\end{pmatrix}$$"

#: src/plonk-arithmetization.md:367
msgid "这正好是三个算术门的计算约束。"
msgstr ""
"This is exactly the calculation constraint of three arithmetic operations."

#: src/plonk-arithmetization.md:369
msgid ""
"总结下，Plonkish 需要一个矩阵 $Q$ 来描述电路空白态，而所有的赋值则写入了 $W$ "
"矩阵。对于 Prover 和 Verifier 的交换协议， $W$ 是 Prover 的 witness，属于秘密"
"知识，对 Verifier 保密， $Q$ 矩阵代表了一个实现双方约定共识的电路描述。"
msgstr ""
"In summary, Plonkish requires a matrix $Q$ to describe the circuit's blank "
"state, while all assignments are written into the matrix $W$. For the "
"exchange protocol between the Prover and Verifier, $W$ is the Prover's "
"witness, which is considered secret and kept confidential from the Verifier. "
"The matrix $Q$ represents a circuit description that achieves consensus "
"between both parties."

#: src/plonk-arithmetization.md:371
msgid "不过仅仅有 $Q$ 矩阵是不足以精确描述上面的例子电路。"
msgstr ""
"However, having only the $Q$ matrix is not sufficient to accurately describe "
"the circuit in the example above."

#: src/plonk-arithmetization.md:373
msgid "复制约束"
msgstr "Copy Constraints"

#: src/plonk-arithmetization.md:375
msgid "比较下面两个电路，它们的 $Q$ 矩阵完全相同，但它们却完全不同。"
msgstr ""
"Compare the following two circuits. Their Q matrices are completely "
"identical, but they are completely different."

#: src/plonk-arithmetization.md:377
msgid "![](img/img20230414205219.png)"
msgstr ""

#: src/plonk-arithmetization.md:379
msgid ""
"两个电路的区别在于 $x_5, x_6$ 是否被接入了 `#1` 号门。如果让 Prover 直接把电"
"路赋值填入 $W$ 表格，一个「诚实的」Prover 会在 $w\\_{a,1}$ 和 $w\\_{c,2}$ 两"
"个位置填上相同的值；而一个「恶意的」Prover 完全可以填上不同的值。如果恶意 "
"Prover 在 $w\\_{b,1}$ 和 $w\\_{c,3}$ 也填入不同的值，那么实际上 Prover 证明的"
"是上图右边的电路，而非是和 Verifier 共识过的电路（左边)。"
msgstr ""
"The difference between the two circuits lies in whether $x_5, x_6$ are "
"connected to gate `#1`. If the Prover directly fills in the assignment of "
"the circuit in the $W$ table, an \"honest\" Prover would fill in the same "
"value in the positions $w_{a,1}$ and $w_{c,2}$; while a \"malicious\" Prover "
"could fill in different values. If the malicious Prover also fills in "
"different values in $w_{b,1}$ and $w_{c,3}$, then in reality, the Prover is "
"proving the circuit on the right side of the diagram, not the agreed-upon "
"circuit between the Verifier and the Prover (on the left side)."

#: src/plonk-arithmetization.md:381
msgid ""
"$$ \\\\begin{array}{c|c|c|c|} i & w_a & w_b & w_c  \\\\ \\\\hline 1 & "
"\\boxed{x_6} & \\underline{x_5} & out \\\\ 2 & x_1 & x_2 & \\boxed{x_6} \\\\ "
"3 & x_3 & x_4 & \\underline{x_5} \\\\ \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:391
msgid ""
"我们需要增加新的约束，强制要求右边电路图中 $x_6=x_7$ 和 $x_5=x_8$。这等价于我"
"们要求 Prover 把同一个变量填入表格多个位置时，**必须填入相等的值**。"
msgstr ""
"We need to add new constraints that require in the right circuit diagram "
"$x_6=x_7$ and $x_5=x_8$. This is equivalent to demanding that when Prover "
"fills in multiple positions in the table with the same variable, **they must "
"fill in equal values**."

#: src/plonk-arithmetization.md:393
msgid ""
"这就需要一类新的约束——「拷贝约束」，即 Copy Constraint。Plonk 采用「置换证"
"明」保证 $W$ 表格中多个位置上的值满足拷贝关系。我们继续用上面这个电路图的案例"
"来说明其基本思路："
msgstr ""
"This requires a new type of constraint called \"Copy Constraint\". Plonk "
"uses \"Permutation Proofs\" to ensure that the values at multiple positions "
"in the table $W$ satisfy the copy relationship. We continue to use the "
"example of the circuit diagram above to illustrate its basic idea:"

#: src/plonk-arithmetization.md:395
msgid "设想我们把 $W$ 表格中的所有位置索引排成一个向量："
msgstr ""
"Imagine that we arrange all the position indices in table $W$ into a vector:"

#: src/plonk-arithmetization.md:397
msgid ""
"$$ \\\\sigma_0=(\\boxed{w\\_{a,1}}, w\\_{a,2}, w\\_{a,3}, "
"\\underline{w\\_{b,1}}, w\\_{b,2}, w\\_{b,3}, w\\_{c,1}, \\boxed{w\\_{c,2}}, "
"\\underline{w\\_{c,3}}) $$"
msgstr ""

#: src/plonk-arithmetization.md:401
msgid ""
"然后把应该相等的两个位置互换，比如上图中要求 $w\\_{a,1}=w\\_{c,2}$ 和 "
"$w\\_{b,1}=w\\_{c,3}$ 。于是我们得到了下面的位置向量："
msgstr ""
"Then swap the two positions that should be equal, for example, in the figure "
"above, it is required that $w\\_{a,1}=w\\_{c,2}$ and $w\\_{b,1}=w\\_{c,3}$. "
"Thus, we obtain the following positional vectors:"

#: src/plonk-arithmetization.md:403
msgid ""
"$$ \\\\sigma=(\\boxed{w\\_{c,2}}, w\\_{a,2}, w\\_{a,3}, "
"\\underline{w\\_{c,3}}, w\\_{b,2}, w\\_{b,3}, w\\_{c,1}, \\boxed{w\\_{a,1}}, "
"\\underline{w\\_{b,1}}) $$"
msgstr ""

#: src/plonk-arithmetization.md:407
msgid ""
"然后我们要求 Prover 证明：**$W$ 表格按照上面的置换之后，仍然等于自身**。置换"
"前后的相等性可以保证 Prover 无法作弊。"
msgstr ""
"Then we ask the Prover to prove that: **$W$ table remains the same after the "
"permutation above**. The equality before and after the permutation ensures "
"that the Prover cannot cheat."

#: src/plonk-arithmetization.md:409
msgid ""
"再来一个例子，当约束一个向量中有三个（或多个）位置上的值必须相同时，只需要把"
"这三个（或多个）位置的值进行循环移位（左移位或者右移位），然后证明移位后的向"
"量与原向量相等即可。比如："
msgstr ""
"Here's another example, when constraining that three (or more) values in a "
"vector must be equal, you only need to shift the values at these three (or "
"more) positions cyclically (left or right), and then prove that the shifted "
"vector is equal to the original vector. For example:"

#: src/plonk-arithmetization.md:411
msgid ""
"$$ A = (b_1, b_2, \\underline{a_1}, b_3, \\underline{a_2}, b_4, "
"\\underline{a_3}) $$"
msgstr ""

#: src/plonk-arithmetization.md:415
msgid "如果要证明 $a_1=a_2=a_3$，那么只需要证明："
msgstr ""
"If we want to prove that $a_1 = a_2 = a_3$, then we only need to prove:"

#: src/plonk-arithmetization.md:417
msgid ""
"$$ A' =  (b_1, b_2, \\underline{a_3}, b_3, \\underline{a_1}, b_2, "
"\\underline{a_2}) \\overset{?}{=} A $$"
msgstr ""

#: src/plonk-arithmetization.md:421
msgid ""
"在经过置换的向量 $A'$ 中， $a_1, a_2, a_3$ 依次右移交换，即 $a_1$ 放到了原来 "
"$a_2$ 的位置，而 $a_2$ 放到了 $a_3$ 的位置， $a_3$ 则放到了 $a_1$ 的位置。"
msgstr ""
"In the vector $A'$ after shuffling, $a_1, a_2, a_3$ are moved and swapped to "
"the right in sequence, meaning $a_1$ is placed in the original position of "
"$a_2$, while $a_2$ is placed in the position of $a_3$, and $a_3$ is placed "
"in the position of $a_1$."

#: src/plonk-arithmetization.md:423
msgid ""
"如果 $A'=A$ ，那么 $A'$ 和 $A$ 所有对应位置上的值都应该相等，可得： "
"$a_1=a_3$， $a_2=a_1$， $a_3=a_2$，即 $a_1=a_2=a_3$。这个方法可以适用于任意数"
"量的等价关系。（后续证明两个向量相等的方法请见下章）"
msgstr ""
"If $A' = A$, then all the values at the corresponding positions of $A'$ and "
"$A$ should be equal. It can be deduced that: $a_1 = a_3$, $a_2 = a_1$, $a_3 "
"= a_2$, which means $a_1 = a_2 = a_3$. This method is applicable to any "
"number of equivalent relationships. (For the subsequent method of proving "
"the equality of two vectors, please refer to the next chapter.)"

#: src/plonk-arithmetization.md:425
msgid ""
"那么如何描述电路赋值表格中的交换呢？我们只需要记录 $\\sigma$ 向量即可，当然 $"
"\\sigma$ 向量也可以写成表格的形式："
msgstr ""
"So how to describe the exchange in the circuit assignment table? We only "
"need to record the $\\sigma$ vector, of course, the $\\sigma$ vector can "
"also be written in the form of a table:"

#: src/plonk-arithmetization.md:427
msgid ""
"$$ \\\\begin{array}{c|c|c|c|} i & \\sigma_a & \\sigma_b & \\sigma_c  \\\\ \\"
"\\hline 1 & \\boxed{w\\_{c,2}} & \\underline{w\\_{c,3}}& w\\_{c,1} \\\\ 2 & "
"w\\_{a,2} & w\\_{b,2} & \\boxed{w\\_{a,1}} \\\\ 3 & w\\_{a,3} & w\\_{b,3} & "
"\\underline{w\\_{b,1}} \\\\ \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:437
msgid "加上 $\\sigma$ ，空白电路可以描述为 $(Q,\\sigma)$ ，电路的赋值为 $W$"
msgstr ""
"Adding $\\sigma$, the blank circuit can be described as $(Q,\\sigma)$, where "
"the assignment of the circuit is $W$."

#: src/plonk-arithmetization.md:439
msgid "$$ \\\\mathsf{Plonkish}\\_0 \\triangleq (Q, \\sigma; W) $$"
msgstr ""

#: src/plonk-arithmetization.md:443
msgid "再比较"
msgstr "Comparison again"

#: src/plonk-arithmetization.md:445
msgid ""
"R1CS 的 $(U,V,W)$ 表格的宽度与引线的数量有关，行数跟乘法门数量有关。这个构造"
"相当于把算术电路看成是仅有乘法门构成，但每个门有多个输入引脚（最多为所有引线"
"的数量）。而 Plonkish 则是同等对待加法门与乘法门，并且因为输入引脚只有两个， "
"所以 $W$ 表格的宽度固定，仅有三列（如果要支持高级的计算门，表格可以扩展到更多"
"列）。这一特性是 Plonk 可以利用 Permutation Argument 实现拷贝约束的前提。"
msgstr ""
"The width of the $(U,V,W)$ table in R1CS depends on the number of wires, and "
"the number of rows depends on the number of multiplication gates. This "
"construction treats arithmetic circuits as consisting only of multiplication "
"gates, but each gate has multiple input pins (up to the total number of "
"wires). On the other hand, Plonkish treats addition and multiplication gates "
"equally, and because there are only two input pins, the width of the $W$ "
"table is fixed at three columns (although the table can be expanded to "
"support more advanced gates). This feature allows Plonk to utilize the "
"Permutation Argument for the implementation of copy constraints."

#: src/plonk-arithmetization.md:447
msgid ""
"..., and thus our linear contraints are just wiring constraints that can be "
"reduced to a permutation check. "
msgstr ""
"I understand. Here is the translated text:\n"
"\n"
"..., y así nuestras restricciones lineales son simplemente restricciones de "
"cableado que se pueden reducir a una comprobación de permutación."

#: src/plonk-arithmetization.md:449
msgid ""
"按照 Plonk 论文的统计，一般情况下，算术电路中加法门的数量是乘法门的两倍。如果"
"这样看来， $W$ 表格的长度会三倍于 R1CS 的矩阵。但这个让步会带来更多的算术化灵"
"活度。"
msgstr ""
"According to the statistics of the Plonk paper, in general, the number of "
"addition gates in arithmetic circuits is twice the number of multiplication "
"gates. If this is the case, the length of the $W$ table will be three times "
"that of the R1CS matrix. However, this concession will provide more "
"arithmetic flexibility."

#: src/plonk-arithmetization.md:451
msgid "电路验证协议框架"
msgstr "Circuit verification protocol framework"

#: src/plonk-arithmetization.md:453
msgid "有了电路空白结构的描述和赋值，我们可以大致描述下 Plonk 的协议框架。"
msgstr ""
"With the description and assignment of the circuit blank structure, we can "
"roughly describe the protocol framework of Plonk."

#: src/plonk-arithmetization.md:455
msgid ""
"首先 Prover 和 Verifier 会对一个共同的电路进行共识， $(Q,\\sigma)$ 。 假设电"
"路的公开输出为 $out=99$，而 $(x_1,x_2,x_3,x_4)$ 为秘密输入。"
msgstr ""
"First, the Prover and Verifier agree on a common circuit, $(Q,\\sigma)$. "
"Assuming the public output of the circuit is $out=99$, and $(x_1,x_2,x_3,"
"x_4)$ are the secret inputs."

#: src/plonk-arithmetization.md:457
msgid "Prover 填写 $W$ 矩阵（Verifier 不可见）："
msgstr "Fill in the $W$ matrix (Invisible to Verifier):"

#: src/plonk-arithmetization.md:459
msgid ""
"$$ \\\\begin{array}{c|c|c|c|} i & w_a & w_b & w_c  \\\\ \\\\hline 1 & "
"\\boxed{x_6} & \\underline{x_5} & \\[out\\] \\\\ 2 & x_1 & x_2 & "
"\\boxed{x_6} \\\\ 3 & x_3 & x_4 & \\underline{x_5} \\\\ 4 & 0 & 0 & "
"\\[out\\] \\\\ \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:470
msgid ""
"其中增加的第四行是为了增加一个额外的算术约束： $out=99$ ，把 $out$ 值显示地表"
"示在 $Q$ 矩阵中。"
msgstr ""
"The additional fourth line is added to introduce an extra arithmetic "
"constraint: $out=99$, where the value of $out$ is explicitly shown in the "
"matrix $Q$."

#: src/plonk-arithmetization.md:472
msgid "相应的那么 Prover 和 Verifier 共识的 $Q$ 矩阵为"
msgstr ""
"The corresponding $Q$ matrix for the consensus of Prover and Verifier is"

#: src/plonk-arithmetization.md:474
msgid ""
"$$ \\\\begin{array}{c|c|c|c|} i & q_L & q_R & q_M & q_C & q_O  \\\\ \\"
"\\hline 1 & 0 & 0 & 1 & 0& 1 \\\\ 2 & 1 & 1 & 0 & 0& 1 \\\\ 3 & 0 & 0 & 1 & "
"0& 1 \\\\ 4 & 0 & 0 & 0 & 99& 1 \\\\ \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:485
msgid ""
"其中第四行约束，保证 $out=99$，可以把 $(q_L=0, q_R=0,q_M=0,q_C=99,q_O=1)$ 代"
"入下面的算术约束，可得 $99-w_c = 0$ ，即 $w\\_{c,4}=99$ 。"
msgstr ""
"I understand. Here is the text:\n"
"\n"
"\"In the fourth line constraint, it ensures that $out=99$. By substituting "
"$(q_L=0, q_R=0, q_M=0, q_C=99, q_O=1)$ into the arithmetic constraint below, "
"we obtain $99-w_c=0$, which means $w_{c,4}=99\".\""

#: src/plonk-arithmetization.md:491
msgid ""
"为了保证第一行的 $w_c$ 也必须为 $99$，这就需要在 $\\sigma$ 矩阵中添加额外的一"
"条拷贝约束：让 $out$ 变量的位置 $(w\\_{c,1})$ 与  第四行的输出 $w\\_{c,4}$ 交"
"换对调："
msgstr ""
"To ensure that the value of $w_c$ in the first row is also $99$, an "
"additional copy constraint needs to be added in the $\\sigma$ matrix: the "
"position of the variable $out$ $w_{c,1}$ should be swapped with the output "
"$w_{c,4}$ of the fourth row."

#: src/plonk-arithmetization.md:493
msgid ""
"$$ \\\\begin{array}{c|c|c|c|} i & \\sigma_a & \\sigma_b & \\sigma_c  \\\\ \\"
"\\hline 1 & \\boxed{w\\_{c,2}} & \\underline{w\\_{c,3}} & \\[w\\_{c,4}\\] \\"
"\\ 2 & w\\_{a,2} & w\\_{b,2} & \\boxed{w\\_{a,1}} \\\\ 3 & w\\_{a,3} & "
"w\\_{b,3} & \\underline{w\\_{b,1}} \\\\ 4 & w\\_{a,4} & w\\_{b,4} & "
"\\[w\\_{c,1}\\]\\\\ \\\\end{array} $$"
msgstr ""

#: src/plonk-arithmetization.md:504
msgid ""
"如果 Prover 是诚实的，那么对于 $i\\in(1,2,3,4)$，下面的算术约束等式成立："
msgstr ""
"If Prover is honest, then the following arithmetic constraint equations hold "
"for $i\\in(1,2,3,4)$:"

#: src/plonk-arithmetization.md:506
msgid ""
"$$ q\\_{L,i} \\circ w\\_{a,i} + q\\_{R,i} \\circ w\\_{b,i} + q\\_{M,"
"i}\\circ(w\\_{a,i}\\cdot w\\_{b,i}) + q\\_{C,i} -  q\\_{O,i}\\circ w\\_{c,i} "
"= 0 $$"
msgstr ""

#: src/plonk-arithmetization.md:510
msgid "验证协议的大概思路如下："
msgstr "The general idea of the verification protocol is as follows:"

#: src/plonk-arithmetization.md:512
msgid ""
"协议开始：Prover 如实填写 $W$ 表格，然后把 $W$ 表格的每一列进行编码，并进行多"
"项式编码，并把编码后的结果发送给 Verifier"
msgstr ""
"Protocol starts: Prover truthfully fills out the $W$ table, then encodes "
"each column of the $W$ table and performs polynomial encoding, and sends the "
"encoded result to Verifier."

#: src/plonk-arithmetization.md:514
msgid ""
"协议验证阶段：Verifier 与 Prover 通过进一步的交互，验证下面的等式是否成立："
msgstr ""
"Agreement verification phase: The Verifier and Prover interact further to "
"verify whether the following equation holds true:"

#: src/plonk-arithmetization.md:516
msgid ""
"$$ q\\_{L}(X) \\cdot w\\_{a}(X) + q\\_{R}(X) \\cdot w\\_{b}(X) + q\\_{M}"
"(X)\\cdot(w\\_{a}(X)\\cdot w\\_{b}(X)) + q\\_{C}(X) -  q\\_{O}(X)\\cdot "
"w\\_{c}(X) \\overset{?}{=} 0 $$"
msgstr ""

#: src/plonk-arithmetization.md:520
msgid ""
"当然这个验证还不够，还要验证 $(\\sigma_a(X),\\sigma_b(X),\\sigma_c(X))$ 与 "
"$(w_a(X),w_b(X),w_c(X))$ 之间的关系。还有，Verifier 如何通过多项式来验证电路"
"的运算，请看后续章节。"
msgstr ""
"Of course, this verification is not enough. We also need to verify the "
"relationship between $(\\sigma_a(X),\\sigma_b(X),\\sigma_c(X))$ and $(w_a(X),"
"w_b(X),w_c(X))$. Also, how does the Verifier verify the circuit operations "
"through polynomials, please refer to the following chapters."

#: src/plonk-arithmetization.md:522
msgid "参考文献"
msgstr "References"

#: src/plonk-arithmetization.md:524
msgid ""
"\\[BG12\\] Bayer, Stephanie, and Jens Groth. \"Efficient zero-knowledge "
"argument for correctness of a shuffle.\" _Annual International Conference on "
"the Theory and Applications of Cryptographic Techniques_. Springer, Berlin, "
"Heidelberg, 2012."
msgstr ""
"I understand. Here is the translation:\n"
"\n"
"\\[BG12\\] Bayer, Stephanie, and Jens Groth. \"Efficient zero-knowledge "
"argument for correctness of a shuffle.\" _Annual International Conference on "
"the Theory and Applications of Cryptographic Techniques_. Springer, Berlin, "
"Heidelberg, 2012."

#: src/plonk-arithmetization.md:525
msgid ""
"\\[GWC19\\] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. "
"\"Plonk: Permutations over lagrange-bases for oecumenical noninteractive "
"arguments of knowledge.\" _Cryptology ePrint Archive_ (2019)."
msgstr ""
"I understand. Here is the text:\n"
"\n"
"\\[GWC19\\] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. "
"\"Plonk: Permutations over lagrange-bases for oecumenical noninteractive "
"arguments of knowledge.\" _Cryptology ePrint Archive_ (2019)."
